#!/usr/bin/env node
/* vim: set ft=javascript: */

/*
 * promstat: command-line Prometheus poller
 */

var mod_assertplus = require('assert-plus');
var mod_cmdutil = require('cmdutil');
var mod_getopt = require('posix-getopt');
var mod_jsprim = require('jsprim');
var mod_tab = require('tab');
var mod_url = require('url');
var VError = require('verror');

var lib_promstat = require('../lib/promstat');
var lib_si = require('../lib/setinterval');

function main()
{
	var parser, option, args, p, t;
	var promstatCmd;

	mod_cmdutil.configure({
	    'usageMessage': 'poll and report Prometheus agent stats',
	    'synopses': [
		'[-j/--json] -t/--target URL ... -m/--metric METRIC_NAME ... ' +
		    '[INTERVAL [COUNT]]'
	    ]
	});

	/*
	 * promstatCmd holds the state of this program.  This is mostly the
	 * (immutable) arguments to the program, plus some state associated with
	 * the pretty-printers.
	 *
	 * If the user requested JSON output with -j/--json, we'll switch this
	 * to promstatReportJson.  Otherwise, if there's only one metric, we'll
	 * use promstatReportTable to emit a compact tabular form.  Otherwise,
	 * we'll use promstatReportFull.
	 */
	promstatCmd = {
	    /* list of metric names requested by the user */
	    'ps_metrics': [],
	    /* list of targets requested by the user */
	    'ps_targets': [],
	    /* interval (in milliseconds) to collect datapoints */
	    'ps_intervalms': 1000,
	    /* number of datapoints to collect before exiting */
	    'ps_ndatapoints': null,
	    /* number of datapoints emitted */
	    'ps_nemitted': 0,
	    /* handle to promstat library object */
	    'ps_promstat': null,
	    /* interval timer handle */
	    'ps_interval': null,

	    /* consume() operation is currently running */
	    'ps_running': false,

	    /* output function */
	    'ps_print': null,
	    /* timestamp of last data point emitted */
	    'ps_last_time': null,
	    /* node-tab table (only for tabular output) */
	    'ps_table': null
	};

	/*
	 * Parse named command-line arguments.
	 */
	parser = new mod_getopt.BasicParser('j(json)m:(metric)t:(target)',
	    process.argv);
	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
		case 'j':
			promstatCmd.ps_print = promstatReportJson;
			break;

		case 'm':
			p = option.optarg;
			/* TODO check this regexp against Prom docs */
			if (!/^[a-zA-Z_0-9]+$/.test(p)) {
				mod_cmdutil.usage('unsupported argument ' +
				    'for -m/--metric: "%s"', p);
			}
			promstatCmd.ps_metrics.push(p);
			break;

		case 't':
			t = validateTarget(option.optarg);
			if (t instanceof Error) {
				mod_cmdutil.usage(new VError(t,
				    'unsupported argument for -t/--target: ' +
				    '"%s"', option.optarg));
			}
			promstatCmd.ps_targets.push(t);
			break;

		default:
			mod_cmdutil.usage();
			break;
		}
	}

	/*
	 * Parse optional command-line arguments: INTERVAL and COUNT.
	 */
	args = process.argv.slice(parser.optind());
	if (args.length > 0) {
		p = mod_jsprim.parseInteger(args[0], {
		    'allowSign': false,
		    'trimWhitespace': true
		});

		if (!(p instanceof Error) && p === 0) {
			p = new VError('must be positive');
		}

		if (p instanceof Error) {
			mod_cmdutil.usage(new VError(
			    p, 'unsupported interval: "%s"', args[0]));
		}

		promstatCmd.ps_intervalms = p * 1000;

		if (args.length > 1) {
			p = mod_jsprim.parseInteger(args[1], {
			    'allowSign': false,
			    'trimWhitespace': true
			});

			if (!(p instanceof Error) && p === 0) {
				p = new VError('must be positive');
			}

			if (p instanceof Error) {
				mod_cmdutil.usage(new VError(
				    p, 'unsupported count: "%s"', args[1]));
			}

			promstatCmd.ps_ndatapoints = p;
		}
	}

	if (promstatCmd.ps_metrics.length === 0) {
		mod_cmdutil.usage('must specify at least one metric');
	}

	if (promstatCmd.ps_targets.length === 0) {
		mod_cmdutil.usage('must specify at least one target');
	}

	if (promstatCmd.ps_print === null) {
		if (promstatCmd.ps_metrics.length == 1) {
			promstatCmd.ps_print = promstatReportTable;
			promstatCmd.ps_table = new mod_tab.TableOutputStream({
			    'columns': [ {
			        'label': 'TIME',
				'width': 8
			    }, {
				'label': 'TARGET',
				'width': 35
			    }, {
				'label': promstatCmd.ps_metrics[0],
				'align': 'right',
				'width': promstatCmd.ps_metrics[0].length
			    } ]
			});
		} else {
			promstatCmd.ps_print = promstatReportFull;
		}
	}

	promstatGo(promstatCmd);
}

/*
 * Given an argument for the "-t/--target" option, check whether it is a valid,
 * supported URL.  If so, return a parsed version of it.  If not, return an
 * error.
 */
function validateTarget(target)
{
	var u, p;

	mod_assertplus.string(target, 'target');
	u = mod_url.parse(target);
	if (u.protocol != 'http:') {
		return (new VError('must be "http"'));
	}

	if (!u.slashes) {
		return (new VError('bad URL format'));
	}

	if (u.auth !== null) {
		return (new VError('auth not supported'));
	}

	if (u.hash !== null) {
		return (new VError('hash not supported'));
	}

	if (u.search !== null) {
		return (new VError('query string not supported'));
	}

	if (u.port !== null) {
		p = mod_jsprim.parseInteger(u.port, {
		    'allowSign': false
		});
		if (!(p instanceof Error)) {
			if (p <= 0 || p >= 65536) {
				p = new VError('port number out of range');
			}
		}
		if (p instanceof Error) {
			return (new VError(p, 'bad TCP port'));
		}
	} else {
		p = 80;
	}

	return ({
	    't_label': u.hostname + ':' + u.port,
	    't_hostname': u.hostname,
	    't_port': p,
	    't_pathname': u.pathname
	});
}

/*
 * Kick off the "promstat" program.
 */
function promstatGo(args)
{
	var promstat;

	mod_assertplus.object(args, 'args');
	mod_assertplus.arrayOfObject(args.ps_targets, 'args.ps_targets');
	mod_assertplus.arrayOfString(args.ps_metrics, 'args.ps_metrics');
	mod_assertplus.number(args.ps_intervalms, 'args.ps_intervalms');
	mod_assertplus.optionalNumber(args.ps_ndatapoints,
	    'args.ps_ndatapoints');

	args.ps_promstat = promstat = new lib_promstat.Promstat();
	args.ps_targets.forEach(function (t) {
		promstat.addTarget(t);
	});
	args.ps_metrics.forEach(function (m) {
		promstat.addMetric(m);
	});

	args.ps_interval = lib_si.setIntervalPrecise(
	    promstatTick, args.ps_intervalms, args, promstat);
}

/*
 * Invoked once per interval to fetch stats and print them out.  This currently
 * skips an iteration if any call is outstanding.
 */
function promstatTick(promstatCmd)
{
	var when;

	if (promstatCmd.ps_running) {
		/* TODO what do we really want to do in this case? */
		return;
	}

	/*
	 * If this is the last data point, all we have to do to stop the program
	 * is to clear the interval timer.
	 */
	++promstatCmd.ps_nemitted;
	if (promstatCmd.ps_ndatapoints !== null &&
	    promstatCmd.ps_nemitted == promstatCmd.ps_ndatapoints) {
		lib_si.clearIntervalPrecise(promstatCmd.ps_interval);
	}

	when = new Date();
	promstatCmd.ps_running = true;
	promstatCmd.ps_promstat.consume(function onConsume(merr, results) {
		promstatCmd.ps_running = false;

		if (merr) {
			VError.errorForEach(merr, function (err) {
				mod_cmdutil.warn(err);
			});
		}

		promstatReport(when, promstatCmd, results);
	});
}

/*
 * Invoked after we've finished collecting data points from all targets to
 * process the output and print it out.
 */
function promstatReport(when, promstatCmd, results)
{
	mod_jsprim.forEachKey(results, function (_, result) {
		mod_assertplus.object(result.target, 'result.target');
		mod_assertplus.object(result.metrics, 'result.metrics');

		promstatCmd.ps_metrics.forEach(function (metname) {
			var met, value;

			met = result.metrics[metname];
			if (!met) {
				value = 'no data';
			} else {
				switch (met.type) {
				case 'counter':
					value = 0;
					mod_jsprim.forEachKey(
					    met.valuesByFields,
					    function (f, v) {
						value += v;
					    });
					break;

				default:
					value = 'unsupported metric type';
					break;
				}
			}

			promstatCmd.ps_print(promstatCmd, {
			    'when': when,
			    'target': result.target,
			    'metricName': metname,
			    'value': value
			});

			promstatCmd.ps_last_time = when.getTime();
		});
	});
}

/*
 * Outputters
 */

/*
 * Compact, tabular output is used when there's exactly one metric.
 */
function promstatReportTable(promstatCmd, datapoint)
{
	var timestr, row;

	timestr = datapoint.when.toISOString();
	timestr = timestr.substr('2017-09-25T'.length, '15:40:22'.length);
	row = {
	    'TIME': timestr,
	    'TARGET': datapoint.target.t_label
	};
	row[datapoint.metricName] = datapoint.value;
	promstatCmd.ps_table.writeRow(row);
}

/*
 * Full output is used by default.  It's not especially convenient to read, but
 * it includes all of the data.
 */
function promstatReportFull(promstatCmd, datapoint)
{
	if (promstatCmd.ps_last_time != datapoint.when.getTime()) {
		console.log('\n' + datapoint.when.toISOString());
	}

	console.log(datapoint.target.t_label);
	console.log('%s %s', datapoint.metricName, datapoint.value);
}

/*
 * If the consumer wants JSON output, they may as well use the HTTP API that
 * we're querying directly, but we have it here because it's easy to do.
 */
function promstatReportJson(promstatCmd, datapoint)
{
	console.log(JSON.stringify(datapoint));
}

main();
