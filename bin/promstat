#!/usr/bin/env node
/* vim: set ft=javascript: */

/*
 * promstat: command-line Prometheus poller
 *
 * There are a few levels of abstraction here:
 *
 * - promstat (this program): responsible for parsing command-line arguments,
 *   managing a handle to the promstat library (in ./lib), and printing out
 *   results.
 *
 * - lib/promstat.js (library): responsible for fetching metrics provided by
 *   targets and tracking the values for the metrics requested by the user
 *
 * - lib/prometheus.js: responsible for fetching metrics provided by a target
 *
 * As an example, a user may request a metric like "http_requests_completed"
 * from each of three targets.  promstat (the program) will instantiate a
 * promstat library handle that requests that we track this metric from these
 * three targets.  The promstat library handle will fetch _all_ metrics from
 * each target (since that's the only operation that Prometheus provides), map
 * those metrics onto whatever the user requested, and interpret the results
 * accordingly (e.g., subtract values for counters, do nothing for gauges, etc).
 */

var mod_assertplus = require('assert-plus');
var mod_cmdutil = require('cmdutil');
var mod_extsprintf = require('extsprintf');
var mod_getopt = require('posix-getopt');
var mod_jsprim = require('jsprim');
var mod_tab = require('tab');
var mod_url = require('url');
var VError = require('verror');

var printf = mod_extsprintf.printf;

var lib_promstat = require('../lib/promstat');
var lib_si = require('../lib/setinterval');

var PROMSTAT_CONCURRENCY = 10;
var PROMSTAT_TIMEOUT = 5000;

function main()
{
	var parser, option, args, p, t;
	var promstatCmd;

	mod_cmdutil.configure({
	    'usageMessage': 'poll and report Prometheus agent stats',
	    'synopses': [
		'-l/--list [-v/--verbose] -t/--target URL',
		'[-j/--json] -t/--target URL ... -m/--metric METRIC_NAME ... ' +
		    '[INTERVAL [COUNT]]'
	    ]
	});

	/*
	 * promstatCmd holds the state of this program.  This is mostly the
	 * (immutable) arguments to the program, plus some state associated with
	 * the pretty-printers.
	 *
	 * If the user requested JSON output with -j/--json, we'll switch this
	 * to promstatReportJson.  Otherwise, if there's only one metric, we'll
	 * use promstatReportTable to emit a compact tabular form.  Otherwise,
	 * we'll use promstatReportFull.
	 */
	promstatCmd = {
	    /* list of metric names requested by the user */
	    'ps_metrics': [],
	    /* list of targets requested by the user */
	    'ps_targets': [], /* XXX remove this */
	    'ps_consumer': new lib_promstat.PromConsumer(),
	    /* interval (in milliseconds) to collect datapoints */
	    'ps_intervalms': 1000,
	    /* number of datapoints to collect before exiting */
	    'ps_ndatapoints': null,
	    /* number of datapoints emitted */
	    'ps_nemitted': 0,
	    /* handle to promstat library object */
	    'ps_promstat': null,
	    /* interval timer handle */
	    'ps_interval': null,

	    /* consume() operation is currently running */
	    'ps_running': false,

	    /* output function */
	    'ps_print': null,
	    /* timestamp of last data point emitted */
	    'ps_last_time': null,
	    /* node-tab table (only for tabular output) */
	    'ps_table': null,

	    /* just list the metrics */
	    'ps_listonly': false,
	    /* verbose listing */
	    'ps_verbose': false
	};

	/*
	 * Parse named command-line arguments.
	 */
	parser = new mod_getopt.BasicParser('l(list)j(json)m:(metric)' +
	    't:(target)v(verbose)', process.argv);
	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
		case 'j':
			if (promstatCmd.ps_listonly) {
				mod_cmdutil.usage('cannot use -j/--json with ' +
				    '-l/--list');
			}
			promstatCmd.ps_print = promstatReportJson;
			break;

		case 'l':
			if (promstatCmd.ps_print !== null ||
			    promstatCmd.ps_metrics.length > 0) {
				mod_cmdutil.usage('cannot use -l/--list with ' +
				    '-j/--json or -m/--metric');
			}
			promstatCmd.ps_listonly = true;
			break;

		case 'm':
			if (promstatCmd.ps_listonly) {
				mod_cmdutil.usage('cannot use -m/--metric ' +
				    'with -l/--list');
			}
			p = option.optarg;
			/* TODO check this regexp against Prom docs */
			if (!/^[a-zA-Z_0-9]+$/.test(p)) {
				mod_cmdutil.usage('unsupported argument ' +
				    'for -m/--metric: "%s"', p);
			}
			promstatCmd.ps_metrics.push(p);
			break;

		case 't':
			t = validateTarget(option.optarg);
			if (t instanceof Error) {
				mod_cmdutil.usage(new VError(t,
				    'unsupported argument for -t/--target: ' +
				    '"%s"', option.optarg));
			}
			promstatCmd.ps_targets.push(t);
			promstatCmd.ps_consumer.addTarget({
			    'label': t.t_label,
			    'hostname': t.t_hostname,
			    'port': t.t_port,
			    'pathname': t.t_pathname
			});
			break;

		case 'v':
			promstatCmd.ps_verbose = true;
			break;

		default:
			mod_cmdutil.usage();
			break;
		}
	}

	/*
	 * Parse optional command-line arguments: INTERVAL and COUNT.
	 */
	args = process.argv.slice(parser.optind());
	if (args.length > 0) {
		if (promstatCmd.ps_listonly) {
			mod_cmdutil.usage('unexpected arguments');
		}

		p = mod_jsprim.parseInteger(args[0], {
		    'allowSign': false,
		    'trimWhitespace': true
		});

		if (!(p instanceof Error) && p === 0) {
			p = new VError('must be positive');
		}

		if (p instanceof Error) {
			mod_cmdutil.usage(new VError(
			    p, 'unsupported interval: "%s"', args[0]));
		}

		promstatCmd.ps_intervalms = p * 1000;

		if (args.length > 1) {
			p = mod_jsprim.parseInteger(args[1], {
			    'allowSign': false,
			    'trimWhitespace': true
			});

			if (!(p instanceof Error) && p === 0) {
				p = new VError('must be positive');
			}

			if (p instanceof Error) {
				mod_cmdutil.usage(new VError(
				    p, 'unsupported count: "%s"', args[1]));
			}

			promstatCmd.ps_ndatapoints = p;
		}
	}

	if (!promstatCmd.ps_listonly) {
		if (promstatCmd.ps_verbose) {
			mod_cmdutil.usage('unexpected argument: -v/--verbose');
		}

		if (promstatCmd.ps_metrics.length === 0) {
			mod_cmdutil.usage('must specify at least one metric');
		}
	}

	if (promstatCmd.ps_targets.length === 0) {
		mod_cmdutil.usage('must specify at least one target');
	}

	/*
	 * XXX remove code for handling the list case elsewhere
	 */
	if (promstatCmd.ps_listonly) {
		promstatListMetrics(promstatCmd);
		return;
	}

	if (!promstatCmd.ps_listonly && promstatCmd.ps_print === null) {
		if (promstatCmd.ps_metrics.length == 1) {
			promstatCmd.ps_print = promstatReportTable;
			promstatCmd.ps_table = new mod_tab.TableOutputStream({
			    'columns': [ {
			        'label': 'TIME',
				'width': 8
			    }, {
				'label': 'TARGET',
				'width': 35
			    }, {
				'label': promstatCmd.ps_metrics[0],
				'align': 'right',
				'width': promstatCmd.ps_metrics[0].length
			    } ]
			});
		} else {
			promstatCmd.ps_print = promstatReportFull;
		}
	}

	promstatGo(promstatCmd);
}

/*
 * Given an argument for the "-t/--target" option, check whether it is a valid,
 * supported URL.  If so, return a parsed version of it.  If not, return an
 * error.
 */
function validateTarget(target)
{
	var u, p;

	mod_assertplus.string(target, 'target');
	u = mod_url.parse(target);
	if (u.protocol != 'http:') {
		return (new VError('must be "http"'));
	}

	if (!u.slashes) {
		return (new VError('bad URL format'));
	}

	if (u.auth !== null) {
		return (new VError('auth not supported'));
	}

	if (u.hash !== null) {
		return (new VError('hash not supported'));
	}

	if (u.search !== null) {
		return (new VError('query string not supported'));
	}

	if (u.port !== null) {
		p = mod_jsprim.parseInteger(u.port, {
		    'allowSign': false
		});
		if (!(p instanceof Error)) {
			if (p <= 0 || p >= 65536) {
				p = new VError('port number out of range');
			}
		}
		if (p instanceof Error) {
			return (new VError(p, 'bad TCP port'));
		}
	} else {
		p = 80;
	}

	return ({
	    't_label': u.hostname + ':' + u.port,
	    't_hostname': u.hostname,
	    't_port': p,
	    't_pathname': u.pathname
	});
}

/*
 * Kick off the mode where we list metric metadata.
 */
function promstatListMetrics(args)
{
	lib_promstat.promListMetrics({
	    'concurrency': PROMSTAT_CONCURRENCY,
	    'requestTimeout': PROMSTAT_TIMEOUT,
	    'consumer': args.ps_consumer
	}, function (err, metadata) {
		if (!metadata) {
			mod_cmdutil.fail(err);
		}

		promstatReportMetrics(args, metadata);

		if (err) {
			VError.errorForEach(err, function iterError(e) {
				mod_cmdutil.warn(e);
			});
		}
	});
}

/*
 * Kick off the "promstat" program.
 */
function promstatGo(args)
{
	var promstat;

	mod_assertplus.object(args, 'args');
	mod_assertplus.arrayOfObject(args.ps_targets, 'args.ps_targets');
	mod_assertplus.arrayOfString(args.ps_metrics, 'args.ps_metrics');
	mod_assertplus.number(args.ps_intervalms, 'args.ps_intervalms');
	mod_assertplus.optionalNumber(args.ps_ndatapoints,
	    'args.ps_ndatapoints');

	args.ps_promstat = promstat = new lib_promstat.Promstat();
	args.ps_targets.forEach(function (t) {
		promstat.addTarget(t);
	});
	args.ps_metrics.forEach(function (m) {
		promstat.addMetric(m);
	});

	if (!args.ps_listonly) {
		args.ps_interval = lib_si.setIntervalPrecise(
		    promstatTick, args.ps_intervalms, args);
	}

	setImmediate(promstatTick, args);
}

/*
 * Invoked once per interval to fetch stats and print them out.  This currently
 * skips an iteration if any call is outstanding.
 */
function promstatTick(promstatCmd)
{
	var when;

	if (promstatCmd.ps_running) {
		/* TODO what do we really want to do in this case? */
		return;
	}

	/*
	 * If this is the last data point, all we have to do to stop the program
	 * is to clear the interval timer.
	 */
	++promstatCmd.ps_nemitted;
	if (promstatCmd.ps_ndatapoints !== null &&
	    promstatCmd.ps_nemitted == promstatCmd.ps_ndatapoints) {
		lib_si.clearIntervalPrecise(promstatCmd.ps_interval);
	}

	when = new Date();
	promstatCmd.ps_running = true;
	promstatCmd.ps_promstat.consume(function onConsume(merr) {
		promstatCmd.ps_running = false;

		if (merr) {
			VError.errorForEach(merr, function (err) {
				mod_cmdutil.warn(err);
			});
		}

		if (promstatCmd.ps_listonly) {
			/* XXX remove */
			promstatReportMetrics(promstatCmd);
		} else {
			promstatReport(when, promstatCmd,
			    promstatCmd.ps_promstat.allValues());
		}
	});
}

/*
 * Invoked after we've finished collecting data points from all targets to
 * process the output and print it out.
 */
function promstatReport(when, promstatCmd, allvalues)
{
	if (promstatCmd.ps_last_time === null) {
		promstatCmd.ps_last_time = when.getTime();
		return;
	}

	mod_jsprim.forEachKey(allvalues, function (tid, result) {
		mod_assertplus.object(result.target, 'result.target');
		mod_assertplus.object(result.metrics, 'result.metrics');

		result.metrics.forEach(function (metric) {
			promstatCmd.ps_print(promstatCmd, {
			    'when': when,
			    'target': result.target,
			    'metricName': metric.m_name,
			    'value': metric.m_value
			});

			promstatCmd.ps_last_time = when.getTime();
		});
	});
}


/*
 * Outputters
 */

/*
 * Compact, tabular output is used when there's exactly one metric.
 */
function promstatReportTable(promstatCmd, datapoint)
{
	var timestr, row;

	timestr = datapoint.when.toISOString();
	timestr = timestr.substr('2017-09-25T'.length, '15:40:22'.length);
	row = {
	    'TIME': timestr,
	    'TARGET': datapoint.target.t_label
	};
	row[datapoint.metricName] = datapoint.value;
	promstatCmd.ps_table.writeRow(row);
}

/*
 * Full output is used by default.  It's not especially convenient to read, but
 * it includes all of the data.
 */
function promstatReportFull(promstatCmd, datapoint)
{
	if (promstatCmd.ps_last_time != datapoint.when.getTime()) {
		console.log('\n' + datapoint.when.toISOString());
	}

	console.log(datapoint.target.t_label);
	console.log('%s %s', datapoint.metricName, datapoint.value);
}

/*
 * If the consumer wants JSON output, they may as well use the HTTP API that
 * we're querying directly, but we have it here because it's easy to do.
 */
function promstatReportJson(promstatCmd, datapoint)
{
	console.log(JSON.stringify(datapoint));
}

/*
 * Outputter that just lists the metrics.
 */
function promstatReportMetrics(promstatCmd, metadata)
{
	printf('%-10s %-30s %s\n', 'TYPE', 'METRIC', 'NTARGS');
	metadata.metrics.forEach(function (metric) {
		printf('%-10s %-30s %6d\n', metric.pmm_type, metric.pmm_name,
		    metric.pmm_ntargets);

		if (promstatCmd.ps_verbose) {
			printf('    %s\n', metric.pmm_help);
		}

	});
}

main();
